如果说，数学是思维的体操，那设计模式，就是面向对象编程思维的体操。
我学了设计模式后时常会过度设计，如何办?
作者建议，暂时现象，继续努力。
```
因为怕过度设计而不用设计模式显然是因噎废食。当你认识到自己有过度使用模式的时候，那就明你已意识到问题的存在，只有通过不断的钻研和努力，你才能突破"不识庐山真面目，只缘身在此山中"的瓶颈，达到"会当凌绝顶，一览众山小"的境界。
```



## 0. 设计模式常用组合

* 一般情况 singleton(单例) factory(工厂) builder(建造者) 这3个或几个会组合一起使用
* 代理模式(proxy) 的动态代理 是aop的基础
* 装饰模式 的典型应该是 io流的设计上
* 行为型模式应用比较广，需要多了解

责任链， 策略， iterator




# 一、创建型模式

## 1. 单例模式

###    1.1 定义（应用场景）

保证一个类仅有一个实例，并提供一个访问它的方法（全局访问点）


###    1.2 开发中的常见场景

* 读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
* 网站的计数器，一般也是采用单例模式实现，否则难以同步。
* 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
* 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
* 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
* 在servlet编程中，每个Servlet也是单例
* 在spring MVC框架/struts1框架中，控制器对象也是单例



###    1.3 常见的单例实现方式

###   # 1. 饿汉式（hungry）

```
不管你用的用不上，一开始就建立这个单例对象，线程安全，效率高
缺点是 不用时也初始化对象了
```

###   # 2. 懒汉式（lazy）

```
真正用到的时候才去建这个单例对象，延迟加载，资源利用高
缺点是 并发调用效率低因为加了同步锁的关系
```

###   # 3. 静态内部类（hungry+lazy）

```
真正用到的时候才去建这个单例对象，延迟加载，资源利用高，且并发调用效率高
缺点是 没什么缺点
```
###   # 4. 枚举方式（enum）





## 2. 工厂模式

###    2.1 应用场景

* spring中IOC容器创建管理bean对象


###    2.2 开发中的常见场景



###    2.1 简单工厂模式（静态工厂模式）

实现简单 也比较常用

违反了开闭原则，扩展时会不停修改 工厂类，一般是可以接收这样的改动

###    2.2 方法工厂模式

简单工厂的细化，有了更好的扩展性，但是增加了复杂度，实际开发中一般这样使用

###    2.3 抽象工厂模式

用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）



## 3. 抽象工厂

###    3.1 定义（应用场景）

用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

###    3.2 开发中的常见场景





## 4. 建造者模式 builder

###    4.1 定义（应用场景）

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。


 ###    4.2 开发中的常见场景

* SQL中的PreparedStatement 
* JDOM中，DomBuilder



## 5. 原型模式（克隆模式）

 ###    5.1 定义（应用场景）

原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。

 ###    5.2 开发中的常见场景

* spring中bean的创建实际就是两种：单例模式+原型模式。



# 二、结构型模式

## 6. 适配器模式 adapter

 ###    6.1 定义（应用场景）

 使原本由于接口不兼容不能一起工作的类可以一起工作，在系统设计时 这个模式一开始推荐不使用，等版本升级过程中遇到了不可修改的几个相似的接口或类时才考虑使用。

（如果能事先预防接口的问题，就能避免问题；在有小的接口不统一问题发生时，及时重构，问题不至于扩大；只有碰到无法改变原有设计和代码的情况时，才考虑适配）

 ###    6.2 开发中的常见场景

* io流 的转换流。

###    6.3 实现

类适配器模式和 对象适配器模式，由于Java不能多继承，所以考虑 对象适配器模式，将2个类似功能的接口 通过一个中间接口进行匹配达到适配的目的。




## 7. 代理模式（主要是动态代理）proxy

 ###    7.1 定义（应用场景）

 

 ###    7.2 开发中的常见场景

* mybatis中实现拦截器插件。
* spring中AOP的实现
* RMI远程方法调用

###    7.3 基于jdk实现动态代理（注意原理）

https://blog.csdn.net/xiaokang123456kao/article/details/77679848

就是动态生成了class文件，基于接口的原因是底层已经继承了Proxy类，所以只能基于接口来实现，而且面向接口编程也是推崇的方式 



## 8. 桥接模式（桥梁模式）bridge

 ###    8.1 定义（应用场景）

多个变化纬度 用多层继承来实现扩展性不好

 ###    8.2 开发中的常见场景

* 银行日志管理：
	* 格式分类：操作日志、交易日志、异常日志
	* 距离分类：本地记录日志、异地记录日志
* 人力资源系统中的奖金计算模块：
	* 奖金分类：个人奖金、团体奖金、激励奖金。
	* 部门分类：人事部门、销售部门、研发部门。
* OA系统中的消息处理：
	* 业务类型：普通消息、加急消息、特急消息
	* 发送消息方式：系统内消息、手机短信、邮件






## 9. 组合模式

 ###    9.1 定义（应用场景）

 

 ###    9.2 开发中的常见场景





## 10. 装饰模式 decorator

###    10.1 定义（应用场景）



###    10.2 开发中的常见场景






## 11.外观模式（门面模式） facade

###    11.1 定义（应用场景）

为子系统中的一组接口提供一个一致的界面，外部调用简单，不用接触太多对象。

###    11.2 开发中的常见场景

* 将多个服务 整合为一个接口，提供服务（经典的3层思想就体现了门面模式）
* 对于复杂难以维护的老系统，直接去改或去扩展都可能产生很多问题，分两个小组，一个开发Facade与老系统的交互，另一个只要了解Facade的接口，直接开发新系统调用这些接口即可，确实可以减少很多不必要的麻烦。



## 12. 享元模式 flyweight

###    12.1 定义（应用场景）



###    12.2 开发中的常见场景





# 三、行为型模式


## 13.责任链模式 chain of responsibility

###    13.1 定义（应用场景）



###    13.2 开发中的常见场景





## 14. 命令模式 command

###    14.1 定义（应用场景）



###    14.2 开发中的常见场景





## 15.解释器模式 interpreter

###    15.1 定义（应用场景）



###    15.2 开发中的常见场景





## 16. 迭代器模式 iterator

###    16.1 定义（应用场景）

分离了集合对象的遍历行为，抽象出一个迭代器类来负责。

这样可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。

###    16.2 开发中的常见场景

jdk内置的迭代器，foreach/Iterator




## 17.中介者模式 mediator

###    17.1 定义（应用场景）

保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。

###    17.2 开发中的常见场景

* 棋类游戏中的 悔棋
* 数据库中的事务管理中的回滚



## 18. 备忘录模式 memento

###    18.1 定义（应用场景）



###    18.2 开发中的常见场景





## 19. 观察者模式 observer

观察者模式又叫 发布-订阅（publish/subscribe）模式

###    19.1 定义（应用场景）

一个对象的改变需要同时改变其他对象的时候，而且不知道具体有多少对象待改变时，

###    19.2 开发中的常见场景

* 委派事件模型
* 邮件订阅
* 广播机制





jdk默认提供了 java.util.Observable（通知者）和 java.util.Observer（观察者）

为什么 通知者是类，观察者是接口？

因为观察者的具体实现会根据需求来变化，通知者的操作基本一样





## 20. 状态模式 state

###    20.1 定义（应用场景）

当一个对象的状态转换的判断过于复杂时，把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。如果状态判断逻辑简单就没必要使用该模式。

###    20.2 开发中的常见场景

* 状态流转，审批功能	



## 21. 策略模式 strategy

###    21.1  定义（应用场景）

针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。

策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。

###    21.2 开发中的常见场景





## 22. 模板方法模式 template

###    22.1 定义（应用场景）



###    22.2 开发中的常见场景






## 23. 访问者模式 visitor

###    23.1 定义（应用场景）



###    23.2 开发中的常见场景



